using Graphs
using StatsBase
using Random
using DataStructures

""" 
STILL IN PROGRESS!!!

Implementing the Louvain algorithm for community detection based on NetworkX's Python implementation
https://networkx.org/documentation/stable/_modules/networkx/algorithms/community/louvain.html#louvain_communities
"""

function louvain_communities(G::AbstractGraph, resolution::Float64=1, threshold::Float64=0.0000001, max_level=None, seed=None)
    """Find the best partition of a graph using the Louvain Community Detection Algorithm.

    Louvain Community Detection Algorithm is a simple method to extract the community
    structure of a network. This is a heuristic method based on modularity optimization. [1]_

    The algorithm works in 2 steps. On the first step it assigns every node to be
    in its own community and then for each node it tries to find the maximum positive
    modularity gain by moving each node to all of its neighbor communities. If no positive
    gain is achieved the node remains in its original community.

    Parameters
    ----------
    G : Julia graph
    weight : string or None, optional (default="weight")
        The name of an edge attribute that holds the numerical value
        used as a weight. If None then each edge has weight 1.
    resolution : float, optional (default=1)
        If resolution is less than 1, the algorithm favors larger communities.
        Greater than 1 favors smaller communities
    threshold : float, optional (default=0.0000001)
        Modularity gain threshold for each level. If the gain of modularity
        between 2 levels of the algorithm is less than the given threshold
        then the algorithm stops and returns the resulting communities.
    max_level : int or None, optional (default=None)
        The maximum number of levels (steps of the algorithm) to compute.
        Must be a positive integer or None. If None, then there is no max
        level and the threshold parameter determines the stopping condition.
    seed : integer, random_state, or None (default)
        Indicator of random number generation state.
        See :ref:`Randomness<randomness>`.

    Returns
    -------
    list
        A list of sets (partition of `G`). Each set represents one community and contains
        all the nodes that constitute it.

    Examples
    --------
    ***

    Notes
    -----
    The order in which the nodes are considered can affect the final output. In the algorithm
    the ordering happens using a random shuffle.

    References
    ----------
    .. [1] Blondel, V.D. et al. Fast unfolding of communities in
       large networks. J. Stat. Mech 10008, 1-12(2008). https://doi.org/10.1088/1742-5468/2008/10/P10008
    .. [2] Traag, V.A., Waltman, L. & van Eck, N.J. From Louvain to Leiden: guaranteeing
       well-connected communities. Sci Rep 9, 5233 (2019). https://doi.org/10.1038/s41598-019-41695-z
    .. [3] Nicolas Dugué, Anthony Perez. Directed Louvain : maximizing modularity in directed networks.
        [Research Report] Université d’Orléans. 2015. hal-01231784. https://hal.archives-ouvertes.fr/hal-01231784

    See Also
    --------
    louvain_partitions
    """
# to be filled in
    partitions = louvain_partitions(G,  resolution = resolution, threshold = threshold, seed = seed)
    
    if max_level !== nothing
        if max_level <= 0
            throw(ArgumentError("max_level argument must be a positive integer or nothing"))
        end
        partitions = Iterators.take(partitions, max_level)
    end
    
    final_partition = collect(partitions)
    return final_partition[end]
end

function louvain_partitions(G::AbstractGraph, resolution::Float64=1, threshold::Float64=0.0000001, seed=None )
    """Yields partitions for each level of the Louvain Community Detection Algorithm

    Louvain Community Detection Algorithm is a simple method to extract the community
    structure of a network. This is a heuristic method based on modularity optimization. [1]_

    The partitions at each level (step of the algorithm) form a dendrogram of communities.
    A dendrogram is a diagram representing a tree and each level represents
    a partition of the G graph. The top level contains the smallest communities
    and as you traverse to the bottom of the tree the communities get bigger
    and the overall modularity increases making the partition better.

    Each level is generated by executing the two phases of the Louvain Community
    Detection Algorithm.

    Be careful with self-loops in the input graph. These are treated as
    previously reduced communities -- as if the process had been started
    in the middle of the algorithm. Large self-loop edge weights thus
    represent strong communities and in practice may be hard to add
    other nodes to.  If your input graph edge weights for self-loops
    do not represent already reduced communities you may want to remove
    the self-loops before inputting that graph.

    Parameters
    ----------
    G : Graph object
    weight : string or None, optional (default="weight")
     The name of an edge attribute that holds the numerical value
     used as a weight. If None then each edge has weight 1.
    resolution : float, optional (default=1)
        If resolution is less than 1, the algorithm favors larger communities.
        Greater than 1 favors smaller communities
    threshold : float, optional (default=0.0000001)
     Modularity gain threshold for each level. If the gain of modularity
     between 2 levels of the algorithm is less than the given threshold
     then the algorithm stops and returns the resulting communities.
    seed : integer, random_state, or None (default)
     Indicator of random number generation state.
     See :ref:`Randomness<randomness>`.

    Yields
    ------
    list
        A list of sets (partition of `G`). Each set represents one community and contains
        all the nodes that constitute it.

    References
    ----------
    .. [1] Blondel, V.D. et al. Fast unfolding of communities in
       large networks. J. Stat. Mech 10008, 1-12(2008)

    See Also
    --------
    louvain_communities
    """

    partition = [Set(u) for u in vertices(G)]

    ## case where graph is empty:
    if isempty(G)
        throw(ArgumentError("Graph is empty."))
    end

    ## using julia graphs built in modularity function
    mod = modularity(G, partition, γ=resolution) 

    is_directed = G.is_directed()

    ### finish this
    graph = Graph()
    add_verticies!(graph, nv(G))
    for e in edges(G)
        add_edge!(graph, e.src, e.dst) # TODO: Weighted?
    end

    m = ne(G)
    partition, inner_partition, improvement = _one_level(graph, m , partition, resolution, is_directed, seed)

   improvement = true 
   while improvement
    yield([copy(s) for s in partition])
    new_mod = modularity(graph, inner_partition, γ=resolution)
    if new_mod - mod <= threshold
        return
    end

    mod = new_mod
    graph = _gen_graph(graph, inner_partition)
    partition, inner_partition, improvement = _one_level(graph, m, partition, resolution, is_directed, seed)
end


function _one_level(G::AbstractGraph, m::Int64, partition, resolution=1, is_directed=False, seed=None)
    """Calculate one level of the Louvain partitions tree

    Parameters
    ----------
    G : Julia Graphs Graph/DiGraph
        The graph from which to detect communities
    m : number
        The size of the graph `G`.
    partition : list of sets of nodes
        A valid partition of the graph `G`
    resolution : positive number
        The resolution parameter for computing the modularity of a partition
    is_directed : bool
        True if `G` is a directed graph.
    seed : integer, random_state, or None (default)
        Indicator of random number generation state.
        See :ref:`Randomness<randomness>`.

    """

    node2com = Dict(u => i for (i, u) in enumerate(G.nodes()))
    inner_partition = [Set(u) for u in vertices(G)]
    if is_directed
        in_degrees = Dict(v => indegree(G, v) for v in vertices) # TODO: implement for weighted edges
        out_degrees = Dict(v => outdegree(G, v) for v in vertices)

        Stot_in = collect(values(in_degrees))
        Stot_out = collect(values(out_degrees))
            
        nbrs = Dict()
        for u in G
            for v in outneighbors(G, u)
                if u != v
                    nbrs[u][v] = get(nbrs[u], v, 0) + 1
                end
            end

            for v in inneighbors(G, u)
                if u != v
                    nbrs[u][v] = get(nbrs[u], v, 0) + 1
                end
            end
        end

    else
        degrees = Dict(v => degree(G, v) for v in vertices)
        Stot= collect(values(degrees))

        nbrs = Dict(u => Set(neighbor(G, u)) for u in vertices(G))
    end

    rand_nodes = collect(vertices(G))
    shuffle!(rand_nodes)
    nb_moves = 1
    improvement = false    
    while nb_moves > 0
        nb_moves = 0
        for u i in rand_nodes
            best_mod = 0
            best_com = node2com[u]
            weights2com = _neighbor_weights(nbrs[u], node2com)
            if is_directed
                in_degrees = in_degrees[u]
                out_degrees = out_degrees[u]
                Stot_in[best_com] -= in_degrees
                Stot_out[best_com] -= out_degrees
                remove_cost = (
                    -weights2com[best_com] / m
                    + resolution
                    * (out_degree * Stot_in[best_com] + in_degree * Stot_out[best_com])
                    / m^2
                )
            else
                degree = degrees[u]
                Stot[best_com] -= degree
                remove_cost = -weights2com[best_com] / m + resolution * (
                    Stot[best_com] * degree
                ) / (2 * m^2)

            end
        end
        for nbr_com, wt in weights2com
            if is_directed
                gain = (
                    remove_cost
                    + wt / m
                    - resolution
                    * (
                        out_degree * Stot_in[nbr_com]
                        + in_degree * Stot_out[nbr_com]
                    )
                    / m^2
                )
            else
                gain = (
                    remove_cost
                    + wt / m
                    - resolution * (Stot[nbr_com] * degree) / (2 * m^2)
                )
            end

            if gain > best_mod:
                best_mod = gain
                best_com = nbr_com
            end
        if is_directed
            Stot_in[best_com] += in_degree
            Stot_out[best_com] += out_degree
        else
            Stot[best_com] += degree 
        end
        if best_com != node2com[u]
            # com = get(vertices(G)[u], 
            # TODO: Finish function implementation

end

function _neighbor_weights(nbrs::Dict, node2com::Dict)
    """Calculate weights between node and its neighbor communities.
    
    Parameters
    ----------
    nbrs : dictionary
           Dictionary with nodes' neighbors as keys and their edge weight as value.
    node2com : dictionary
           Dictionary with all graph's nodes as keys and their community index as value.

    """
    weights = Dict{Int, Float64}()
    
    for (nbr, wt) in nbrs
        com = node2com[nbr]
        weights[com] = get(weights, com, 0.0)
    end

    return weights

end

function _gen_graph(G::AbstractGraph, partition)
    """Generate a new graph based on the partitions of a given graph"""
    # note: every partition is one node, and the edge weights represent the edges between communties. 
    # weighted self loops reflect internal edges in communities

    # new graph with one node for each partition
    n = length(partition) 
    H = Graph(n) 
    # TODO: make this code work
    for i, part in enumerate(partition)
        nodes = Set()
        for node in part:
            node2com[node] = i
            ## TODO: figure out how to do update and add node
            nodes.update(G.nodes[node].get("nodes", {node}))
        end
        H.add_node(i, nodes=nodes)
    end

    for node1, node2, wt in G.edges(data=True):
        wt = wt["weight"]
        com1 = node2com[node1]
        com2 = node2com[node2]
        # temp = H.get_edge_data(com1, com2, {"weight": 0})["weight"] fix
        # H.add_edge(com1, com2, weight=wt + temp)
    end
    return H
end
